\documentclass[11pt,oneside,onecolumn,openany,spanish]{book}

\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{babel}
%\usepackage[spanish,activeacute]{babel}
\usepackage{mathtools}
\usepackage{multirow} 
\usepackage{tikz}
\usetikzlibrary{automata,positioning}
\usetikzlibrary{babel}
\usetikzlibrary{arrows,decorations.pathmorphing,backgrounds,fit,positioning,shapes.symbols,chains}

\title{Práctica PL}
\author{Elena Kaloyanova Popova y Álvaro Velasco García}
\date{2018}

\begin{document}
% cuerpo del documento
\newcommand{\mystar}{{\fontfamily{lmr}\selectfont$\star$}}
\newcommand\tab[1][0.7cm]{\hspace*{#1}}

\maketitle
\tableofcontents % crea el índice

%---------------------------------------------------------------------
%                   Capítulo 1 - Analizador léxico
%---------------------------------------------------------------------
\chapter{Fase 1: Analizador léxico}

%---------------------------------------------------------------------
\section{Clases Léxicas}
%---------------------------------------------------------------------
\label{cap1:sec:clases_lexicas}
Todo programa consta de dos secciones: una para las declaraciones y otra para las instrucciones, separadas por un token "`\&\&"'. La sección de declaraciones está formada por una serie de declaraciones compuestas por el nombre de tipo y el de variable y separadas por un punto y coma. La sección de instrucciones, por su parte, consta de una serie de asignaciones (variable=expresión), separadas también por un punto y coma.
Las clases léxicas que hemos considerado para representar los tokens del lenguaje son las siguientes:

\begin{itemize}
	\item \textbf{SEC:} Representa el seccionador de las dos partes del programa ("`\&\&"').
	\item \textbf{NUM:} Palabra reservada "`num"'.
	\item \textbf{BOOL:} Palabra reservada "`bool"'.
	\item \textbf{VAR:} Representa el nombre de la variable. Comienza necesariamente por una letra, seguida por una secuencia de cero o más letras, dígitos o el símbolo "`\_"'.
	\item \textbf{ASIG:} Representa el signo igual de las asignaciones.
	\item \textbf{NXT:} Representa el signo "`;"' que marca el comienzo de la siguiente instrucción.
	\item \textbf{TRUE:} Palabra reservada "`true"'.
	\item \textbf{FALSE:} Palabra reservada "`false"'.
	\item \textbf{NUMR:} Representa un número real. Puede empezar opcionalmente con un signo seguido de una secuencia de uno o más digitos cualesquiera, pudiendo poner ceros no significativos a la izquierda. Puede opcionalmente estar seguido por una parte decimal y/o una parte exponencial.
	\item \textbf{MAS:} Operador suma (\textbackslash +).
	\item \textbf{MENOS:} Operador resta (\textbackslash -).
	\item \textbf{POR:} Operador multiplicación (\textbackslash *).
	\item \textbf{DIV:} Operador división (/).
	\item \textbf{AND:} Palabra reservada "`and"'.
	\item \textbf{OR:} Palabra reservada "`or"'.
	\item \textbf{NOT:} Palabra reservada "`not"'.
	\item \textbf{MAY:} Operador mayor (>).
	\item \textbf{MEN:} Operador menor (<).
	\item \textbf{MAYI:} Operador mayor o igual (>=).
	\item \textbf{MENI:} Operador menor o igual (<=).
	\item \textbf{IGUAL:} Operador igual a (==).
	\item \textbf{DIST:} Operador distinto a (!=).
	\item \textbf{PAP:} Signo de apertura de paréntesis.
	\item \textbf{PCI:} Signo de cierre de paréntesis.
	\item \textbf{EOF:} Representa el final de fichero.

\end{itemize}
%---------------------------------------------------------------------
\section{Especificación Formal}
%---------------------------------------------------------------------
\label{cap1:sec:especificacion_formal}

Las definiciones regulares correspondientes a las clases léxicas definidas son:

	\textbf{(\mystar )  SEC:} [\&][\&]
	
	\textbf{(\mystar ) VAR:} \underline{LETRA}([\underline{LETRA}|\underline{DIG}|\textbackslash \_]*)
	
	\tab \textbf{LETRA:} ([a-z,A-Z])
	
	\tab \textbf{DIG:} ([0-9])
	
	\textbf{(\mystar ) NUM:} ([n][u][m])
	
	\textbf{(\mystar ) BOOL:} ([b][o][o][l])
	
	\textbf{(\mystar ) TRUE:} ([t][r][u][e])
	
	\textbf{(\mystar ) FALSE:} ([f][a][l][s][e])
	
	\textbf{(\mystar ) NUMR:} \underline{SIGNO}?(\underline{DIG}+(\underline{DEC})?(\underline{EX})?) 
	
	\tab \textbf{DEC:} (\textbackslash .)\underline{DIG}+ 
	
	\tab \textbf{EX:} [e|E](\underline{SIGNO}?\underline{DIG}+)
	
	\tab \textbf{SIGNO:} [\textbackslash +,\textbackslash -] 
	
	\tab \textbf{DIG:} [0-9]
	
	\textbf{(\mystar ) AND:} ([a][n][d])
	
	\textbf{(\mystar ) OR:} ([o][r])
	
	\textbf{(\mystar ) NOT:} ([n][o][t])
	
	\textbf{(\mystar ) MAS:} (\textbackslash +)
	
	\textbf{(\mystar ) MENOS:} (\textbackslash -)
	
	\textbf{(\mystar ) DIV:} (/)
	
	\textbf{(\mystar ) POR:} (\textbackslash *)
	
	\textbf{(\mystar ) MAY:} (>)
	
	\textbf{(\mystar ) MEN:} (<)
	
	\textbf{(\mystar ) MAYI:} ([>][=])
	
	\textbf{(\mystar ) MENI:} ([<][=])
	
	\textbf{(\mystar ) IGUAL:} ([=][=])
	
	\textbf{(\mystar ) DIST:} ([!][=])
	
	\textbf{(\mystar ) ASIG:} (=)
	
	\textbf{(\mystar ) NXT:} (;)
	
	\textbf{(\mystar ) PAP:} (\textbackslash $($)
	
	\textbf{(\mystar ) PCIERRE:} (\textbackslash $)$)
	
	\textbf{(\mystar ) SEP:} ["` "',\textbackslash t,\textbackslash n,\textbackslash r,\textbackslash b]
	
%---------------------------------------------------------------------
\section{Diseño}
%---------------------------------------------------------------------
\label{cap1:sec:disenyo}

\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
    \node[state] (q_0) {INICIO};
    \node[state, accepting] (q_1) [above=3of q_0]  {R\_ASIG};
    \node[state, accepting] (q_2) [left=2.5of q_1] {R\_PCI};
    \node[state, accepting] (q_3) [above=3of q_2] {R\_PAP};
    \node[state, accepting] (q_4) [above=3of q_1] {R\_IGUAL};
    \node[state, accepting] (q_5) [right=2.3of q_1] {R\_MEN};
    \node[state, accepting] (q_6) [right=2of q_5] {R\_MAY};
    \node[state] (q_7) [right=2of q_6] {R\_EXL};
    \node[state, accepting] (q_8) [above=3of q_5] {R\_MENI};
    \node[state, accepting] (q_9) [above=3of q_6] {R\_MAYI};
    \node[state, accepting] (q_10) [above=3of q_7] {R\_DIST};
    \node[state, accepting] (q_11) [below=3of q_0] {R\_MENOS};
		\node[state, accepting] (q_12) [left=3of q_11] {R\_MAS};
    \node[state, accepting] (q_13) [right=3of q_11] {R\_POR};
    \node[state, accepting] (q_14) [below=of q_13] {R\_DIV};
    \node[state, accepting] (q_15) [below=4of q_11] {R\_ENT};
    \node[state] (q_16) [right=3of q_15] {R\_P};
    \node[state, accepting] (q_17) [right=3of q_16] {R\_DEC};
    \node[state] (q_18) [below=3.2of q_17] {R\_E};
    \node[state] (q_19) [left=3of q_18] {R\_SIGNO};
    \node[state, accepting] (q_20) [left=3of q_19] {R\_EX};
    \node[state, accepting] (q_21) [right=8of q_0] {R\_VAR};
    \node[state, accepting] (q_22) [below=2of q_21] {R\_FIN};
    \node[state] (q_23) [below=6.5of q_7] {R\_AMP};
    \node[state, accepting] (q_24) [below=4of q_22] {R\_SEC};
		\node[state, accepting] (q_25) [below=1.8of q_2] {R\_NXT};
			\path[->]
          (q_0) edge [loop left] node {$[$' ',\textbackslash t,\textbackslash n,\textbackslash r,\textbackslash b]} (q_0)
                edge node [fill=white, anchor=center, pos=0.5]          {=} (q_1)
                edge node [fill=white, anchor=center, pos=0.5]     {$)$} (q_2)
                edge node [fill=white, anchor=center, pos=0.5]           {$($} (q_3)
                edge node [fill=white, anchor=center, pos=0.5]           {$<$} (q_5)
                edge [bend right=5] node [fill=white, anchor=center, pos=0.5] {$>$} (q_6)
                edge [bend right=25] node [fill=white, anchor=center, pos=0.5] {!} (q_7)
                edge node [fill=white, anchor=center, pos=0.5] {-} (q_11)
                edge node [fill=white, anchor=center, pos=0.5] {+} (q_12)
                edge node [fill=white, anchor=center, pos=0.5] {$\ast$} (q_13)
                edge  node [fill=white, anchor=center, pos=0.5] {/} (q_14)
                edge [bend right=35]  node [fill=white, anchor=center, pos=0.5] {Dig} (q_15)
                edge  node [fill=white, anchor=center, pos=0.5] {Letra} (q_21)
                edge  node [fill=white, anchor=center, pos=0.5] {EOF} (q_22)
                edge  node [fill=white, anchor=center, pos=0.5] {\&} (q_23)
								edge  node [fill=white, anchor=center, pos=0.5] {;} (q_25)
          (q_1) edge  node[fill=white, anchor=center, pos=0.5]     {=} (q_4)
          (q_5) edge  node [fill=white, anchor=center, pos=0.5]            {=} (q_8)
          (q_6) edge  node [fill=white, anchor=center, pos=0.5]            {=} (q_9)
          (q_7) edge node [fill=white, anchor=center, pos=0.5] {=} (q_10)
          (q_11) edge node [fill=white, anchor=center, pos=0.5] {Dig} (q_15)
          (q_12) edge node [fill=white, anchor=center, pos=0.5] {Dig} (q_15)
          (q_15) edge [loop below] node {Dig} (q_15)
                 edge node [fill=white, anchor=center, pos=0.5] {\textbackslash .} (q_16)
                 edge node [fill=white, anchor=center, pos=0.5] {e|E} (q_18)
          (q_16) edge node [fill=white, anchor=center, pos=0.5] {Dig} (q_17)
          (q_17) edge [loop above] node {Dig} (q_17)
                 edge node [fill=white, anchor=center, pos=0.5] {e|E} (q_18)
          (q_18) edge [bend left=40] node [fill=white, anchor=center, pos=0.5] {Dig} (q_20)
                 edge node [fill=white, anchor=center, pos=0.5] {-,+} (q_19)
					(q_19) edge node [fill=white, anchor=center, pos=0.5] {Dig} (q_20)
					(q_20) edge [loop left] node {Dig} (q_20)
          (q_21) edge [loop above=0.5] node {Letra|Dig|\_} (q_21)
          (q_23) edge node [fill=white, anchor=center, pos=0.5] {\&} (q_24);
  \end{tikzpicture}
	
%---------------------------------------------------------------------
%                   Capítulo 2 - Analizador sintáctico
%---------------------------------------------------------------------
\chapter{Fase 2: Analizador sintáctico}
En esta fase desarrollaremos el analizador sintáctico descendente predictivo para el lenguaje descrito en la primera fase. 
%---------------------------------------------------------------------
\section{Gramática incontextual}
%---------------------------------------------------------------------
\label{cap2:sec:gramatica_incontextual}

\subsection{Operadores}
Empezaremos definiendo la gramática incontextual que define el lenguaje. Los operadores que utiliza nuestro lenguaje aparecen en la tabla \ref{tabla:operadores}.

\begin{table}[htbp]
	\centering
		\begin{tabular}{|c|c|c|c|}
			\hline
			Operador & Prioridad & Tipo & Asociatividad \\
			\hline 
			+,- & 0 & Binario infijo & Asocia Izquierda \\ \hline
			\multirow{ 2}{*} and & {1} & {Binarios infijos} & Asocia Derecha \\ or & & & No asocia \\ \hline
			Relacionales & 2 & Binario infijo & No asocia \\ \hline
			*,/ & 3 & Binario infijo & Asocia Izquierda \\ \hline
			\multirow{ 2}{*} - & {4} & {Unarios prefijos} & Asocia \\ not & & & No asocia \\
			\hline
		\end{tabular}
		\caption{Operadores}
		\label{tabla:operadores}
\end{table}

\subsection{Gramática incontextual}
La gramática incotextual obtenida apartir de la definición y los operadores es la siguiente:

S $\rightarrow$ Programa \underline{EOF}

Programa $\rightarrow$ LDs \underline{SEC} LIs

LDs $\rightarrow$ LDs \underline{NXT} Declaracion

LDs $\rightarrow$ Declaracion

Declaracion $\rightarrow$ \underline{NUM} \underline{VAR}

Declaracion $\rightarrow$ \underline{BOOL} \underline{VAR}

LIs $\rightarrow$ LIs \underline{NXT} Instruccion

LIs $\rightarrow$ Instruccion

Instruccion $\rightarrow$ \underline{VAR} \underline{ASIG} EXP0

\

EXP0 $\rightarrow$ EXP0 OP0 EXP1

EXP0 $\rightarrow$ EXP1 

EXP1 $\rightarrow$ EXP2 \underline{AND} EXP1 

EXP1 $\rightarrow$ EXP2 \underline{OR} EXP2  

EXP1 $\rightarrow$ EXP2

EXP2 $\rightarrow$ EXP3 OP2 EXP3 

EXP2 $\rightarrow$ EXP3 

EXP3 $\rightarrow$ EXP3 OP3 EXP4 

EXP3 $\rightarrow$ EXP4 

EXP4 $\rightarrow$ \underline{MENOS} EXP4

EXP4 $\rightarrow$ \underline{NOT} EXP5

EXP4 $\rightarrow$ EXP5 

EXP5 $\rightarrow$ \underline{NUMR}

EXP5 $\rightarrow$ \underline{VAR}

EXP5 $\rightarrow$ \underline{TRUE}

EXP5 $\rightarrow$ \underline{FALSE}

EXP5 $\rightarrow$ \underline{PAP} EXP0 \underline{PCIERRE} 

OP0 $\rightarrow$ \underline{MAS}

OP0 $\rightarrow$ \underline{MENOS} 

OP2 $\rightarrow$ \underline{MAY} 

OP2 $\rightarrow$ \underline{MEN} 

OP2 $\rightarrow$ \underline{MAYI} 

OP2 $\rightarrow$ \underline{MENI} 

OP2 $\rightarrow$ \underline{IGUAL} 

OP2 $\rightarrow$ \underline{DIST} 

OP3 $\rightarrow$ \underline{POR} 

OP3 $\rightarrow$ \underline{DIV} 

\subsection{Gramática transformada LL(1)}
Necesitamos transformar la gramática a una LL(1). Una vez transformada, la gramática queda de la siguiente manera:

S $\rightarrow$ Programa \underline{EOF}

Programa $\rightarrow$ LDs \underline{SEC} LIs

LDs $\rightarrow$ Declaracion RLDS

RLDS $\rightarrow$ \underline{NXT} Declaracion RLDS

RLDS $\rightarrow$ $\varepsilon$

Declaracion $\rightarrow$ \underline{NUM} \underline{VAR}

Declaracion $\rightarrow$ \underline{BOOL} \underline{VAR}

LIs $\rightarrow$ Instruccion RLIS

RLIS $\rightarrow$ \underline{NXT} Instruccion RLIS

RLIS $\rightarrow$ $\varepsilon$

Instruccion $\rightarrow$ \underline{VAR} \underline{ASIG} EXP0

\
	
EXP0 $\rightarrow$ EXP1 R0

R0 $\rightarrow$ OP0 EXP1 R0

R0 $\rightarrow$ $\varepsilon$

EXP1 $\rightarrow$ EXP2 R1

R1 $\rightarrow$ \underline{AND} EXP1

R1 $\rightarrow$ \underline{OR} EXP2  

R1 $\rightarrow$ $\varepsilon$

EXP2 $\rightarrow$ EXP3 R2 

R2 $\rightarrow$ OP2 EXP3 R2

R2 $\rightarrow$ $\varepsilon$ 

EX3 $\rightarrow$ EXP4 R3

R3 $\rightarrow$ OP3 EXP4 R3

R3 $\rightarrow$ $\varepsilon$

EXP4 $\rightarrow$ \underline{MENOS} EXP4

EXP4 $\rightarrow$ \underline{NOT} EXP5 

EXP4 $\rightarrow$ EXP5

EXP5 $\rightarrow$ \underline{NUMR}

EXP5 $\rightarrow$ \underline{VAR}

EXP5 $\rightarrow$ \underline{TRUE}

EXP5 $\rightarrow$ \underline{FALSE}

EXP5 $\rightarrow$ \underline{PAP} EXP0 \underline{PCIERRE} 

OP0 $\rightarrow$ \underline{MAS}

OP0 $\rightarrow$ \underline{MENOS} 

OP2 $\rightarrow$ \underline{MAY} 

OP2 $\rightarrow$ \underline{MEN} 

OP2 $\rightarrow$ \underline{MAYI} 

OP2 $\rightarrow$ \underline{MENI} 

OP2 $\rightarrow$ \underline{IGUAL} 

OP2 $\rightarrow$ \underline{DIST} 

OP3 $\rightarrow$ \underline{POR} 

OP3 $\rightarrow$ \underline{DIV} 

\subsection{Primeros y siguientes}
Los \textbf{primeros} de nuestra gramática son:

PRIM(S) = \{NUM, BOOL\}

PRIM(PROGRAMA) = \{NUM, BOOL\}

PRIM(LDS) = \{NUM, BOOL\}

PRIM(RLDS) = \{NXT\}

PRIM(DECLARACION) = \{NUM, BOOL\}

PRIM(LIS) = \{VAR\}

PRIM(RLIS) = \{NXT\}

PRIM(INSTRUCCION) = \{VAR\}

PRIM(R0) = \{MAS,MENOS\}

PRIM(R1) = \{AND,OR\}

PRIM(EXP1) = \{MENOS, NOT, NUMR, VAR, TRUE, FALSE, PAP\}

PRIM(EXP2) = \{MENOS, NOT, NUMR, VAR, TRUE, FALSE, PAP\}

PRIM(R2) = \{MAY, MEN, MAYI, MENI, IGUAL, DIST\}

PRIM(EXP3) = \{MENOS, NOT, NUMR, VAR, TRUE, FALSE, PAP\}

PRIM(R3) = \{POR, DIV, MENOS, NOT, NUMR, VAR, TRUE, FALSE, PAP\}

PRIM(EXP4) = \{MENOS, NOT, NUMR, VAR, TRUE, FALSE, PAP\}

PRIM(EXP5) = \{NUMR, VAR, TRUE, FALSE, PAP\}

PRIM(EXP0) = \{MENOS, NOT, NUMR, VAR, TRUE, FALSE, PAP\}

PRIM(OP0) = \{MAS, MENOS\}

PRIM(OP2) = \{MAY, MEN, MAYI, MENI, IGUAL, DIST\}

PRIM(OP3) = \{POR, DIV\}

Los \textbf{siguientes} son:

SIG(S) = \{$\varepsilon$\}

SIG(PROGRAMA) = \{EOF\}

SIG(LDS) = \{SEC\}

SIG(RLDS) = \{SEC\}

SIG(DECLARACION) = \{NXT, SEC\}

SIG(LIS) = \{EOF\}

SIG(RLIS) = \{EOF\}

SIG(INSTRUCCION) = \{NXT,EOF\}

SIG(R0) = \{PCI, NXT, EOF\}

SIG(R1) = \{PCI, MAS, MENOS, NXT, EOF\}

SIG(EXP1) = \{PCI, MAS, MENOS, NXT, EOF\}

SIG(EXP2) = \{PCI, AND, OR, MAS, MENOS, NXT, EOF\}

SIG(R2) = \{PCI, AND, OR, MAS, MENOS, NXT, EOF\}

SIG(EXP3) = \{PCI, MAY, MEN, MAYI, MENI, IGUAL, DIST, AND, OR, MAS, MENOS, NXT, EOF\}

SIG(R3) = \{PCI, MAY, MEN, MAYI, MENI, IGUAL, DIST, AND, OR, MAS, MENOS, NXT, EOF\}

SIG(EXP4) = \{PCI, POR, DIV, NOT, NUMR, VAR, TRUE, FALSE, PAP, MAY, MEN, MAYI, MENI, IGUAL, DIST, AND, OR, MAS, MENOS, NXT, EOF\}

SIG(EXP5) = \{PCI, POR, DIV, NOT, NUMR, VAR, TRUE, FALSE, PAP, MAY, MEN, MAYI, MENI, IGUAL, DIST, AND, OR, MAS, MENOS, NXT, EOF\}

SIG(EXP0) = \{PCI, NXT, EOF\}

SIG(OP0) = \{MENOS, NOT, NUMR, VAR, TRUE, FALSE, PAP\}

SIG(OP2) = \{MENOS, NOT, NUMR, VAR, TRUE, FALSE, PAP\}

SIG(OP3) = \{MENOS, NOT, NUMR, VAR, TRUE, FALSE, PAP\}

\subsection{Directores}
Obtenidos los primeros y los siguientes podemos proceder a calcular los \textbf{directores}:

DIR(S $\rightarrow$ Programa \underline{EOF}) = \{NUM, BOOL\}

DIR(Programa $\rightarrow$ LDs \underline{SEC} LIs \underline{EOF}) = \{NUM, BOOL\}

DIR(LDs $\rightarrow$ Declaracion RLDS) = \{NUM, BOOL\}

DIR(RLDS $\rightarrow$ \underline{NXT} Declaracion RLDS) = \{NXT\}

DIR(RLDS $\rightarrow$ $\varepsilon$) = \{SEC\}

DIR(Declaracion $\rightarrow$ \underline{NUM} \underline{VAR}) = \{NUM\}

DIR(Declaracion $\rightarrow$ \underline{BOOL} \underline{VAR}) = \{BOOL\}

DIR(LIs $\rightarrow$ Instruccion RLIS) = \{VAR\}

DIR(RLIS $\rightarrow$ \underline{NXT} Instruccion RLDS) = \{NXT\}

DIR(RLIS $\rightarrow$ $\varepsilon$) = \{EOF\}

DIR(Instruccion $\rightarrow$ \underline{VAR} \underline{ASIG} EXP0) = \{VAR\}
	
DIR(EXP0 $\rightarrow$ EXP1 R0) = \{MENOS, NOT, NUMR, VAR, TRUE, FALSE, PAP\}

DIR(R0 $\rightarrow$ OP0 EXP1 R0) = \{MAS, MENOS\}

DIR(R0 $\rightarrow$ $\varepsilon$) = \{PCI, NXT, EOF\}

DIR(EXP1 $\rightarrow$ EXP2 R1) = \{MENOS, NOT, NUMR, VAR, TRUE, FALSE, PAP\}

DIR(R1 $\rightarrow$ \underline{AND} EXP1 R1) = \{AND\} 

DIR(R1 $\rightarrow$ \underline{OR} EXP2) = \{OR\}  

DIR(R1 $\rightarrow$ $\varepsilon$) = \{PCI, MAS, MENOS, NXT, EOF\}

DIR(EXP2 $\rightarrow$ EXP3 R2) = \{MENOS, NOT, NUMR, VAR, TRUE, FALSE, PAP\}

DIR(R2 $\rightarrow$ OP2 EXP3 R2) = \{MAY, MEN, MAYI, MENI, IGUAL, DIST\} 

DIR(R2 $\rightarrow$ $\varepsilon$) = \{PCI, AND, OR, MAS, MENOS, NXT, EOF\} 

DIR(EX3 $\rightarrow$ EXP4 R3) = \{MENOS, NOT, NUMR, VAR, TRUE, FALSE, PAP\}

DIR(R3 $\rightarrow$ OP3 EXP4 R3) = \{MUL,DIV\}

DIR(R3 $\rightarrow$ $\varepsilon$) = \{PCI, MAY, MEN, MAYI, MENI, IGUAL, DIST, AND, OR, MAS, MENOS, NXT, EOF\}

DIR(EXP4 $\rightarrow$ \underline{MENOS} EXP4) = \{MENOS\}

DIR(EXP4 $\rightarrow$ \underline{NOT} EXP5) = \{NOT\} 

DIR(EXP4 $\rightarrow$ EXP5) = \{NUMR, VAR, TRUE, FALSE, PAP\}

DIR(EXP5 $\rightarrow$ \underline{NUMR}) = \{NUMR\}

DIR(EXP5 $\rightarrow$ \underline{VAR}) = \{VAR\}

DIR(EXP5 $\rightarrow$ \underline{TRUE}) = \{TRUE\}

DIR(EXP5 $\rightarrow$ \underline{FALSE}) = \{FALSE\}

DIR(EXP5 $\rightarrow$ \underline{PAP} EXP0 \underline {PCIERRE}) = \{PAP\} 

DIR(OP0 $\rightarrow$ \underline{MAS}) = \{MAS\}

DIR(OP0 $\rightarrow$ \underline{MENOS}) = \{MENOS\}

DIR(OP2 $\rightarrow$ \underline{MAY}) = \{MAY\} 

DIR(OP2 $\rightarrow$ \underline{MEN}) = \{MEN\} 

DIR(OP2 $\rightarrow$ \underline{MAYI}) = \{MAYI\} 

DIR(OP2 $\rightarrow$ \underline{MENI}) = \{MENI\}

DIR(OP2 $\rightarrow$ \underline{IGUAL}) = \{IGUAL\} 

DIR(OP2 $\rightarrow$ \underline{DIST}) = \{DIST\} 

DIR(OP3 $\rightarrow$ \underline{POR}) = \{POR\} 

DIR(OP3 $\rightarrow$ \underline{DIV}) = \{DIV\}

%---------------------------------------------------------------------
%                   Capítulo 3 - Analizador sintáctico ascendente
%---------------------------------------------------------------------
\chapter{Fase 3: Analizador sintáctico ascendente}
En esta fase desarrollaremos una versión diferente del analizador sintáctico, esta vez ascendente LR. Se implementará con JLex y Cup haciendo uso de la gramática incontextual desarrollada en la fase 2.


%---------------------------------------------------------------------
%                   Capítulo 4 - Construcción de árboles de sintaxis abstracta
%---------------------------------------------------------------------
\chapter{Fase 4: Construcción de árboles de sintaxis abstracta}

En esta fase desarrollaremos los constructores ascendentes y descendentes del árbol de sintaxis abstracta de la práctica.
%---------------------------------------------------------------------
\section{Funciones constructoras}
%---------------------------------------------------------------------
\label{cap4:sec:funciones_constructoras}

Lo primero que debemos hacer es simplificar la gramática incontextual desarrollada en la fase 2, eliminando las estructuras introducidas con el propósito de evitar ambigüedades. Esta es la gramática resultante de la simplificación:

Programa $\rightarrow$ LDs \underline{SEC} LIs

LDs $\rightarrow$ LDs \underline{NXT} \underline{NUM} \underline{VAR} | LDs \underline{NXT} \underline{BOOL} \underline{VAR} | \underline{NUM} \underline{VAR} | \underline{BOOL} \underline{VAR}

LIs $\rightarrow$ LIs \underline{NXT} \underline{VAR} \underline{ASIG} EXP | \underline{VAR} \underline{ASIG} EXP

EXP $\rightarrow$ EXP \underline{MAS} EXP | EXP \underline{MENOS} EXP | EXP \underline{AND} EXP | EXP \underline{OR} EXP | EXP \underline{MAY} EXP | EXP \underline{MEN} EXP | EXP \underline{MAYI} EXP | EXP \underline{MENI} EXP | EXP \underline{IGUAL} EXP | EXP \underline{DIST} EXP | EXP \underline{POR} EXP | EXP \underline{DIV} EXP | \underline{MENOS} EXP | \underline{NOT} EXP |  \underline{NUMR} | \underline{VAR} | \underline{TRUE} | \underline{FALSE}| \underline{PAP} EXP \underline{PCIERRE} 

Una vez tenemos esta nueva gramática podemos obtener los constructores. Cada producción semánticamente significativa representa una función constructora. En la tabla \ref{tabla:constructoras} podemos ver la lista de constructores obtenidos.

\begin{table}[htbp]
	\centering
		\begin{tabular}{|c|c|}
			\hline
			Regla & Constructora \\
			\hline 
			Programa $\rightarrow$ LDs \underline{SEC} LIs & \textbf{programa}: LDs X LIs $\rightarrow$ Programa \\ \hline
			LDs $\rightarrow$ LDs \underline{NXT} \underline{NUM} \underline{VAR} & \textbf{dnCompuesta}: LDs X String $\rightarrow$ LDs \\ \hline
			LDs $\rightarrow$ LDs \underline{NXT} \underline{BOOL} \underline{VAR} & \textbf{dbCompuesta}: LDs X String $\rightarrow$ LDs \\ \hline
			LDs $\rightarrow$ \underline{NUM} \underline{VAR} & \textbf{dnSimple}: String $\rightarrow$ LDs \\ \hline
			LDs $\rightarrow$ \underline{BOOL} \underline{VAR} & \textbf{dbSimple}: String $\rightarrow$ LDs \\ \hline
			LIs $\rightarrow$ LIs \underline{NXT} \underline{VAR} \underline{ASIG} EXP & \textbf{liCompuesta}: LIs X String X EXP $\rightarrow$ LIs \\ \hline
			LIs $\rightarrow$ \underline{VAR} \underline{ASIG} EXP & \textbf{liSimple}: String X EXP $\rightarrow$ LIs \\ \hline
			EXP $\rightarrow$ EXP \underline{MAS} EXP & \textbf{suma}: EXP X EXP $\rightarrow$ EXP \\ \hline
			EXP $\rightarrow$ EXP \underline{MENOS} EXP & \textbf{resta}: EXP X EXP $\rightarrow$ EXP \\ \hline
			EXP $\rightarrow$ EXP \underline{AND} EXP & \textbf{conj}: EXP X EXP $\rightarrow$ EXP \\ \hline
			EXP $\rightarrow$ EXP \underline{OR} EXP & \textbf{disy}: EXP X EXP $\rightarrow$ EXP \\ \hline
			EXP $\rightarrow$ EXP \underline{MAY} EXP & \textbf{mayor}: EXP X EXP $\rightarrow$ EXP \\ \hline
			EXP $\rightarrow$ EXP \underline{MEN} EXP & \textbf{menor}: EXP X EXP $\rightarrow$ EXP \\ \hline
			EXP $\rightarrow$ EXP \underline{MAYI} EXP & \textbf{mayori}: EXP X EXP $\rightarrow$ EXP \\ \hline
			EXP $\rightarrow$ EXP \underline{MENI} EXP & \textbf{menori}: EXP X EXP $\rightarrow$ EXP \\ \hline
			EXP $\rightarrow$ EXP \underline{IGUAL} EXP & \textbf{igual}: EXP X EXP $\rightarrow$ EXP \\ \hline
			EXP $\rightarrow$ EXP \underline{DIST} EXP & \textbf{distinto}: EXP X EXP $\rightarrow$ EXP \\ \hline
			EXP $\rightarrow$ EXP \underline{POR} EXP & \textbf{mul}: EXP X EXP $\rightarrow$ EXP \\ \hline
			EXP $\rightarrow$ EXP \underline{DIV} EXP & \textbf{div}: EXP X EXP $\rightarrow$ EXP \\ \hline
			EXP $\rightarrow$ \underline{MENOS} EXP & \textbf{signo}: EXP $\rightarrow$ EXP \\ \hline
			EXP $\rightarrow$ \underline{NOT} EXP & \textbf{neg}: EXP $\rightarrow$ EXP \\ \hline
			EXP $\rightarrow$ \underline{NUMR} & \textbf{real}: String $\rightarrow$ EXP \\ \hline
			EXP $\rightarrow$ \underline{VAR} & \textbf{id}: String $\rightarrow$ EXP \\ \hline			
		\end{tabular}
		\caption{Constructoras}
		\label{tabla:constructoras}
\end{table} 

%---------------------------------------------------------------------
\section{Diagrama de clases}
%---------------------------------------------------------------------
\label{cap4:sec:diagrama_clases}

A continuación se muestra el diagrama de clases que nos ayudará a diseñar la sintaxis abstracta del lenguaje.

\begin{figure}[h]

\centering
\begin{tikzpicture}
[node distance = 1cm, auto,font=\footnotesize,
every node/.style={node distance=3cm},
comment/.style={rectangle, inner sep= 5pt, text width=4cm, node distance=0.25cm, font=\scriptsize\sffamily},
force/.style={rectangle, draw, fill=black!10, inner sep=5pt, text width=4cm, text badly centered, minimum height=1.2cm, font=\bfseries\footnotesize\sffamily}] 

% Dibuja los nodos
\node [force] (Programa) {Programa};

\node [force, below of=Programa , left of=Programa] (LDs) {LDs};

	\node [force, below of=LDs , left of=LDs] (dSimple) {dSimple};
	
		\node [force, below of=dSimple , left of=dSimple] (dnSimple) {dnSimple};
		\node [force, below of=dSimple , right of=dSimple] (dbSimple) {dbSimple};

	\node [force, below of=LDs , right of=LDs] (dCompuesta) {dCompuesta};
	
		\node [force, below of=dCompuesta , left of=dCompuesta] (dnCompuesta) {dnCompuesta};
		\node [force, below of=dCompuesta , right of=dCompuesta] (dbCompuesta) {dbCompuesta};

\node [force, below of=Programa , right of=Programa] (LIs) {LIs};

	\node [force] (EXP) {EXP};
	
		\node [force] (ExpBin) {ExpBin};

			\node [force] (and) {and};
			\node [force] (or) {or};
			\node [force] (suma) {suma};
			\node [force] (resta) {resta};
			\node [force] (may) {may};
			\node [force] (men) {men};
			\node [force] (mayi) {mayi};
			\node [force] (meni) {meni};
			\node [force] (dist) {dist};
			\node [force] (disy) {disy};
			\node [force] (conj) {conj};
		
		\node [force] (ExpUn) {ExpUn};
			
			\node [force] (signo) {signo};
			\node [force] (negacion) {negacion};
			
		\node [force] (id) {id};
		\node [force] (real) {real};

%Dibuja las lineas
\path[->,thick] 
(LDs) edge (Programa);

	(dSimple) edge (LDs);
	
		(dnSimple) edge (dSimple);
		(dbSimple) edge (dSimple);
		
	(dCompuesta) edge (LDs);
	
		(dnCompuesta) edge (dCompuesta);
		(dbCompuesta) edge (dCompuesta);

(LIs) edge (Programa);
	
	(EXP) edge (LIs);
		
		(ExpBin) edge (EXP);
		
			(and) edge (ExpBin);
			(or) edge (ExpBin);
			(suma) edge (ExpBin);
			(resta) edge (ExpBin);
			(may) edge (ExpBin);
			(men) edge (ExpBin);
			(mayi) edge (ExpBin);
			(meni) edge (ExpBin);
			(dist) edge (ExpBin);
			(disy) edge (ExpBin);
			(conj) edge (ExpBin);

		(ExpUn) edge (EXP);
			
			(signo) edge (ExpUn);
			(negacion) edge (ExpUn);
			
		(id) edge (EXP);
		(real) edge (EXP);
		
\end{tikzpicture}
\caption{Diagrama de clases}
\label{Diagrama:clases}
\end{figure}
%---------------------------------------------------------------------
\section{Constructor de árboles de sintaxis abstracta}
%---------------------------------------------------------------------
\label{cap4:sec:arboles}

S $\rightarrow$ Programa \underline{EOF}

\tab S.a = Programa.a

Programa $\rightarrow$ LDs \underline{SEC} LIs

\tab Programa.a = programa(LDs.a, LIs.a)

LDs $\rightarrow$ LDs \underline{NXT} Declaracion

\tab LDs\_{0}.a = dCompuesta(LDs.a, Declaracion.a)

LDs $\rightarrow$ Declaracion

\tab LDs.a = Declaracion.a

Declaracion $\rightarrow$ \underline{NUM} \underline{VAR}

\tab Declaracion.a = dnSimple(VAR.lex)

Declaracion $\rightarrow$ \underline{BOOL} \underline{VAR}

\tab Declaracion.a = dbSimple(VAR.lex)

LIs $\rightarrow$ LIs \underline{NXT} Instruccion

\tab LIs\_{0}.a = liCompuesta(LDs.a, Instruccion.id, Instruccion.exp)

LIs $\rightarrow$ Instruccion

\tab LIs.a = liSimple(Instruccion.id, Instruccion.exp)

Instruccion $\rightarrow$ \underline{VAR} \underline{ASIG} EXP0

\tab Intruccion.id = VAR.lex

\tab Instruccion.exp = EXP0.a

\

EXP0 $\rightarrow$ EXP0 OP0 EXP1

\tab EXP0\_{0}.a = mkexpbin(OP0.op, EXP0.a, EXP1.a)

EXP0 $\rightarrow$ EXP1 

\tab EXP0.a = EXP1.a

EXP1 $\rightarrow$ EXP2 \underline{AND} EXP1 

\tab EXP1\_{0}.a = mkexpbin("`and"', EXP2.a, EXP1.a)

EXP1 $\rightarrow$ EXP2 \underline{OR} EXP2  

\tab EXP1.a = mkexpbin("`or"', EXP2\_{0}.a, EXP2.a)

EXP1 $\rightarrow$ EXP2

\tab EXP1.a = EXP2.a

EXP2 $\rightarrow$ EXP3 OP2 EXP3 

\tab EXP2.a = mkexpbin(OP2.op, EXP3\_{0}.a, EXP3.a)

EXP2 $\rightarrow$ EXP3 

\tab EXP2.a = EXP3.a

EXP3 $\rightarrow$ EXP3 OP3 EXP4 

\tab EXP3\_{0}.a = mkexpbin(OP3.op, EXP3.a, EXP4.a)

EXP3 $\rightarrow$ EXP4 

\tab EXP3.a = EXP4.a

EXP4 $\rightarrow$ \underline{MENOS} EXP4

\tab EXP4\_{0}.a = mkexpun("`-"', EXP4.a)

EXP4 $\rightarrow$ \underline{NOT} EXP5 

\tab EXP4.a = mkexpun("`!"', EXP5.a)

EXP4 $\rightarrow$ EXP5 

\tab EXP4.a = EXP5.a

EXP5 $\rightarrow$ \underline{NUMR}

\tab EXP5.a = real(NUMR.lex)

EXP5 $\rightarrow$ \underline{VAR}

\tab EXP5.a = id(VAR.lex)

EXP5 $\rightarrow$ \underline{TRUE}

\tab EXP5.a = "`true"'

EXP5 $\rightarrow$ \underline{FALSE}

\tab EXP5.a = "`false"'

EXP5 $\rightarrow$ \underline{PAP} EXP0 \underline{PCIERRE} 

\tab EXP5.a = EXP0.a

OP0 $\rightarrow$ \underline{MAS}

\tab OP0.op = "`+"'

OP0 $\rightarrow$ \underline{MENOS} 

\tab OP0.op = "`-"'

OP2 $\rightarrow$ \underline{MAY} 

\tab OP2.op = "`>"'

OP2 $\rightarrow$ \underline{MEN} 

\tab OP2.op = "`<"'

OP2 $\rightarrow$ \underline{MAYI} 

\tab OP2.op = "`>="'

OP2 $\rightarrow$ \underline{MENI} 

\tab OP2.op = "`<="'

OP2 $\rightarrow$ \underline{IGUAL} 

\tab OP2.op = "`=="'

OP2 $\rightarrow$ \underline{DIST} 

\tab OP2.op = "`!="'

OP3 $\rightarrow$ \underline{POR} 

\tab OP3.op = "`/"'

OP3 $\rightarrow$ \underline{DIV}

\tab OP3.op = "`/"'

Para poder hacer una implementación descendente es necesario acondicionar la gramática:

S $\rightarrow$ Programa \underline{EOF}

\tab S.a = Programa.a

Programa $\rightarrow$ LDs \underline{SEC} LIs

\tab Programa.a = programa(LDs.a, LIs.a)

LDs $\rightarrow$ Declaracion RLDS

\tab RLDS.ah = dSimple(Declaracion.a)

\tab LDs.a = RLDS.a

RLDS $\rightarrow$ \underline{NXT} Declaracion RLDS

\tab RLDS\_{1}.a = dCompuesta(RLDS\_{0}.ah, Declaracion.a)

\tab RLDS\_{0}.a = RLDS\_{1}.a

RLDS $\rightarrow$ $\varepsilon$

\tab RLDS.a = RLDS.ah

Declaracion $\rightarrow$ \underline{NUM} \underline{VAR}

Declaracion $\rightarrow$ \underline{BOOL} \underline{VAR}

LIs $\rightarrow$ Instruccion RLIS

\tab RLIS.ah = liSimple(Instruccion.id, Instruccion.exp)

\tab LIs.a = RLIS.a

RLIS $\rightarrow$ \underline{NXT} Instruccion RLIS

\tab RLIS\_{1}.a = liCompuesta(RLIS\_{0}.ah, Instruccion.a)

\tab RLIS\_{0}.a = RLIS\_{1}.a

RLIS $\rightarrow$ $\varepsilon$

\tab RLIs.a = RLIs.ah

Declaracion $\rightarrow$ \underline{NUM} \underline{VAR}

\tab Declaracion.a = dnSimple(VAR.lex)

Declaracion $\rightarrow$ \underline{BOOL} \underline{VAR}

\tab Declaracion.a = dbSimple(VAR.lex)

Instruccion $\rightarrow$ \underline{VAR} \underline{ASIG} EXP0

\tab Intruccion.id = VAR.lex

\tab Instruccion.exp = EXP0.a

\

EXP0 $\rightarrow$ EXP1 R0

\tab R0.ah = EXP1.a

\tab EXP0.a = R0.a

R0 $\rightarrow$ OP0 EXP1 R0

\tab R0\_{1}.ah = mkexpbin(OP0.op, R0\_{0}.ah, EXP1.a)

\tab R0\_{0}.a = R0\_{1}.a

R0 $\rightarrow$ $\varepsilon$

\tab R0.a = R0.ah

EXP1 $\rightarrow$ EXP2 R1

\tab R1.ah = EXP2.a

\tab EXP1.a = R1.a

R1 $\rightarrow$ \underline{AND} EXP1

\tab R1\_{1}.ah = mkexpbin("and", R1\_{1}.ah, EXP1.a)

\tab R1\_{0}.a = R1\_{1}.a

R1 $\rightarrow$ \underline{OR} EXP2

\tab R1\_{1}.ah = mkexpbin("or", R1\_{0}.ah, EXP2.a)

\tab R1\_{0}.a = R1\_{1}.a  

R1 $\rightarrow$ $\varepsilon$

\tab R1.a = R1.ah

EXP2 $\rightarrow$ EXP3 R2

\tab R2.ah = EXP3.a

\tab EXP2.a = R2.a

R2 $\rightarrow$ OP2 EXP3 R2

\tab R2\_{1}.ah = mkexpbin(OP2.op, R2\_{0}.ah, EXP3.a)

\tab R2\_{0}.a = R2\_{1}.a

R2 $\rightarrow$ $\varepsilon$ 

\tab R2.a = R2.ah

EX3 $\rightarrow$ EXP4 R3

\tab R3.ah = EXP4.a

\tab EXP3.a = R3.a

R3 $\rightarrow$ OP3 EXP4 R3

\tab R3\_{1}.ah = mkexpbin(OP3.op, R3\_{0}.ah, EXP4.a)

\tab R3\_{0}.a = R3\_{1}.a

R3 $\rightarrow$ $\varepsilon$

\tab R3.a = R3.ah

EXP4 $\rightarrow$ \underline{MENOS} EXP4

\tab EXP4\_{0}.a = mkexpun("-", EXP4.a)

EXP4 $\rightarrow$ \underline{NOT} EXP5 

\tab EXP4.a = mkexpun("!", EXP5.a)

EXP4 $\rightarrow$ EXP5 

\tab EXP4.a = EXP5.a

EXP5 $\rightarrow$ \underline{NUMR}

\tab EXP5.a = real(NUMR.lex)

EXP5 $\rightarrow$ \underline{VAR}

\tab EXP5.a = id(VAR.lex)

EXP5 $\rightarrow$ \underline{TRUE}

\tab EXP5.a = "true"

EXP5 $\rightarrow$ \underline{FALSE}

\tab EXP5.a = "false"

EXP5 $\rightarrow$ \underline{PAP} EXP0 \underline{PCIERRE} 

\tab EXP5.a = EXP0.a

OP0 $\rightarrow$ \underline{MAS}

\tab OP0.op = "`+"'

OP0 $\rightarrow$ \underline{MENOS} 

\tab OP0.op = "`-"'

OP2 $\rightarrow$ \underline{MAY} 

\tab OP2.op = "`>"'

OP2 $\rightarrow$ \underline{MEN} 

\tab OP2.op = "`<"'

OP2 $\rightarrow$ \underline{MAYI} 

\tab OP2.op = "`>="'

OP2 $\rightarrow$ \underline{MENI} 

\tab OP2.op = "`<="'

OP2 $\rightarrow$ \underline{IGUAL} 

\tab OP2.op = "`=="'

OP2 $\rightarrow$ \underline{DIST} 

\tab OP2.op = "`!="'

OP3 $\rightarrow$ \underline{POR} 

\tab OP3.op = "`/"'

OP3 $\rightarrow$ \underline{DIV}

\tab OP3.op = "`/"'


\end{document}




 
