package cup;

import java_cup.runtime.*;
import alex.AnalizadorLexicoJLex;
import alex.UnidadLexica;
import errors.GestionErroresTiny;
import ast.E;
import ast.S;
import ast.LDs;
import ast.LIs;
import ast.ASTiny;

scan with {: return getScanner().next_token(); :};
action code {:
   private ASTiny as = new ASTiny();
:};
parser code {: 
   private GestionErroresTiny errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresTiny();
   AnalizadorLexicoJLex alex = (AnalizadorLexicoJLex)getScanner();
   alex.fijaGestionErrores(errores);
:};


terminal  SEC, NXT, ASIG, AND, OR, NOT, PAP, PCIERRE, MAS, MENOS,
 MAY, MEN, MAYI, MENI, IGUAL, DIST, POR, DIV;
 
terminal String NUMR,TRUE,FALSE,VAR, NUM, BOOL;

non terminal  S Sp, Programa; 
non terminal LDs LDS;
non terminal LIs LIS; 
non terminal E EXP0, EXP1, EXP2, EXP3, EXP4, EXP5;

Sp ::= Programa: valOfp
   {: RESULT=valOfp; :};
Programa ::= LDS: valOfLds SEC LIS: valOfLis
   {: RESULT= as.programa(valOfLds,valOfLis); :};
LDS ::= LDS: valOfLds NXT NUM: lexDeNum VAR: lexDeVar 
   {: RESULT = as.dCompuesta(valOfLds,lexDeNum,lexDeVar); :};
LDS ::= LDS: valOfLds NXT BOOL: lexDeBool VAR: lexDeVar 
   {: RESULT = as.dCompuesta(valOfLds,lexDeBool,lexDeVar); :};
LDS ::= NUM: lexDeNum VAR: lexDeVar 
   {: RESULT = as.dSimple(lexDeNum,lexDeVar); :};
LDS ::= BOOL: lexDeBool VAR: lexDeVar 
   {: RESULT = as.dSimple(lexDeBool,lexDeVar); :};
LIS ::= LIS: valOfLis NXT VAR: lexDeVar ASIG EXP0: valOfExp0
   {: RESULT = as.liCompuesta(valOfLis,lexDeVar,valOfExp0); :};
LIS ::= VAR: lexDeVar ASIG EXP0: valOfExp0
   {: RESULT = as.liSimple(lexDeVar,valOfExp0); :};
EXP0 ::= EXP0: aOfExp0 MAS EXP1: aOfExp1
   {: RESULT = as.suma(aOfExp0,aOfExp1); :};
EXP0 ::= EXP0: aOfExp0 MENOS EXP1: aOfExp1
   {: RESULT = as.resta(aOfExp0,aOfExp1); :};
EXP0 ::= EXP1: valDeExp
   {: RESULT = valDeExp; :};
EXP1 ::= EXP2: aOfExp2 AND EXP1: aOfExp1
   {: RESULT = as.conj(aOfExp2,aOfExp1); :};
EXP1 ::= EXP2: aOfExp2 OR EXP2: aOfExp2p
   {: RESULT = as.disy(aOfExp2,aOfExp2p); :};   
EXP1 ::= EXP2: valDeExp
   {: RESULT = valDeExp; :}; 
EXP2 ::= EXP3: aOfExp3 MAY EXP3: aOfExp3p
   {: RESULT = as.may(aOfExp3,aOfExp3p); :};
EXP2 ::= EXP3: aOfExp3 MEN EXP3: aOfExp3p
   {: RESULT = as.men(aOfExp3,aOfExp3p); :};   
EXP2 ::= EXP3: aOfExp3 MAYI EXP3: aOfExp3p
   {: RESULT = as.mayi(aOfExp3,aOfExp3p); :};
EXP2 ::= EXP3: aOfExp3 MENI EXP3: aOfExp3p
   {: RESULT = as.meni(aOfExp3,aOfExp3p); :};   
EXP2 ::= EXP3: aOfExp3 IGUAL EXP3: aOfExp3p
   {: RESULT = as.igual(aOfExp3,aOfExp3p); :};
EXP2 ::= EXP3: aOfExp3 DIST EXP3: aOfExp3p
   {: RESULT = as.dist(aOfExp3,aOfExp3p); :};      
EXP2 ::= EXP3: valDeExp
   {: RESULT = valDeExp; :}; 
EXP3 ::= EXP3: aOfExp3 POR EXP4: aOfExp4
   {: RESULT = as.mul(aOfExp3,aOfExp4); :};
EXP3 ::= EXP3: aOfExp3 DIV EXP4: aOfExp4
   {: RESULT = as.div(aOfExp3,aOfExp4); :};    
EXP3 ::= EXP4: valDeExp
   {: RESULT = valDeExp; :}; 
EXP4 ::= MENOS EXP4: aOfExp4
   {: RESULT = as.signo(aOfExp4); :};
EXP4 ::= NOT EXP4: aOfExp4
   {: RESULT = as.not(aOfExp4); :};      
EXP4 ::= EXP5: valDeExp
   {: RESULT = valDeExp; :};   
EXP5 ::= NUMR: lexDeNum        
   {: RESULT = as.real(lexDeNum); :};
EXP5 ::= VAR: lexDeVar        
   {: RESULT = as.id(lexDeVar); :};
EXP5 ::= TRUE: lexDeTrue        
   {: RESULT = as.trueCnt(); :};
EXP5 ::= FALSE: lexDeFalse        
   {: RESULT = as.falseCnt(); :};
EXP5 ::= PAP EXP0: valDeExp PCIERRE
   {: RESULT = valDeExp; :};



